===================================
Введение в C++11: Variadic Template
===================================

:author: Igor Kalnitsky
:tags: cpp
:slug: variadic-templates
:status: draft

.. role:: strike
    :class: strike

Давно я не садился за перо и не писал в блог. На то были свои причины, но
сегодня наконец дело сдвинулось с мертвой точки. В интернете все еще немного
информации о стандарте C++ 2011 года. Своей статьей я хочу пополнить
её количество и, возможно, помочь кому-то разобраться в этой тематике.

Ниже я хочу рассказать о новом механизме — механизме весьма мощном и гибком
в умелых руках — именуемом **Variadic Template**. Я соприкасался с ним
в своей прошлой статье о `«Пользовательских литералах»`_, но не объяснял его,
так как это заслуживает отдельной статьи.

    В данной статье под **шаблоном** я буду понимать именно механизм шаблонов
    C++ (**template**), а не паттерны проектирования или что-то другое еще.

Что это такое?
--------------

**Variadic Template** — это такой шаблон, который может принимать переменное
число аргументов. Данный вид шаблонов весьма полезен, так как позволяет
реализовывать многие вещи проще, без :strike:`шаблонных пиздецов` велосипедов
в духе Александреску.

Что же это нам дает? А дает это нам просто широченные возможности. Именно это
позволяет красиво и элегантно создать такие вещи как ``tuple``, ``function`` и
``bind()``. Это также позволяет создать типобезопасную версию ``printf()``,
или распарсить пользовательский литерал.


Первый контакт
--------------

Когда пытаются объяснить суть Variadic Template, зачастую приводят пример
с типобезопасной версией функции ``printf()``. Я отойду от этого канона и
рассмотрю основы работы на более простом примере.

В функциональных языках есть замечательные функции ``any()`` и ``all()``,
которые проверяют входные списки на соответствие предикату. Иными словами,
функция ``any()`` возвращает ``True`` если хотя бы один из элементов списка
удовлетворяет предикату, а ``all()`` — если все элементы удовлетворяют
предикату.

Давайте реализуем аналог ``any()``. Наша версия будет отличаться тем, что
будет принимать не список, а переменное число аргументов.

    В стандарт C++ уже добавлены подобные функции: ``any_of()`` и ``all_of()``.
    Однако, в отличии от нашей версии, принимают они последовательность,
    заданную итераторами.

Сигнатура проектируемой функции будет выглядеть следующим образом.

.. code:: c++

    template <class PRED, class... ARGS>
        bool any(PRED pred, ARGS... args);

Как видно, у нас есть необычно объявленный шаблонный параметр ``ARGS``. Но что
же это за троеточие перед ним? Это так называемый **template parameter pack**
— специальный параметр шаблона, который может принимать 0, 1 и более
аргументов.

Хорошо, а что же тогда ``args``? А это  **function parameter pack** —
специальный аргумент функции, который может принимать любое количество
аргументов, тип которых соответствует указанным в ``template arguments pack``.

Изначально несколько непонятно, поэтому давайте рассмотрим на примере.
Предположим, у нас есть следующим вызов функции.

.. code:: c++

    auto pred = /* some predicate */;
    any(pred, 42, 3.14, 'i');

Тогда,

``ARGS`` = ``int``, ``double`` и ``char``
``args`` = ``42``, ``3.14`` и ``'i'``

Иными словами, ``template parameter pack`` представляет собой набор типов,
в то время как ``function paramater pack`` — набор значений.

Итак, как передать переменное число аргументов мы разобрались. А как с ними
работать? Как извлекать их? Для этого используется механизм, который
напоминает *pattern matching* в языке *Haskell*. Его суть заключается в том,
чтобы рассматривать переменное число аргументов как *аргумент* + *оставшиеся
аргументы*.


Dive in
-------

Рассмотрим на примере реализации нашей функции.

.. code:: c++

    // final case
    template <class PRED>
        bool any(PRED pred)
        {
            return false;
        }

    // iterates through the arguments
    template <class PRED, class T, class... ARGS>
        bool any(PRED pred, T element, ARGS... args)
        {
            if (pred(element))
                return true;
            return any(pred, args...);
        }

    // somewhere else
    auto isZero = [](int x) { return x == 0; };
    std::cout << any(isZero, 7, 8, 2, 0, 3, 6, 9) << std::endl;

Что же здесь происходит? И что же это за новое троеточие, появившееся в 
рекурсивном вызове? Данное троеточие (``args...``) говорит о том, что
необходимо распаковать данные аргументы. То есть, если ``args`` — это аргумент,
которые содержит внутри себя несколько параметров, то ``args...`` фактически
эквивалентно перечислению этих параметров через запятую.

Давайте рассмотрим по шагам что происходит при вышеописанном вызове.

.. code:: text

    #1: происходит вызов функции —  any(isZero, 1, 2, 0, 4)
          - pred = isZero
          - element = 1
          - args = 2, 0, 4

    #2: удовлетворяет ли `element` предикату? нет.

    #3: вызываем рекурсивно себя же.
          - any(pred, args...) ~ any(isZero, 2, 0, 4)

    #4: происходит вызов функции —  any(isZero, 2, 0, 4)
          - pred = isZero
          - element = 2
          - args = 0, 4

    #5: удовлетворяет ли `element` предикату? нет.

    #6: вызываем рекурсивно себя же.
          - any(pred, args...) ~ any(isZero, 0, 4)

    #7: происходит вызов функции —  any(isZero, 0, 4)
          - pred = isZero
          - element = 0
          - args = 4

    #8: удовлетворяет ли `element` предикату? да

    #9: возвращаем `true`

Но зачем же нам нужен вариант функции, который не принимает никаких аргументов,
кроме предиката? Нужен он для предотвращения рекурсии, когда уже все параметры
будут пройдены (``args`` не будет содержать никаких аргументов).

Итак, функция работает и вроде бы все хорошо. Однако на лицо накладные расходы:
аргументы передаются по значению, а значит не избежать копирования. К счастью,
Variadic Template весьма гибки, и позволяют применять к аргументам так
называемые *паттерны*.

    Под *паттернами* я буду понимать не паттерны проектирования, а просто
    некоторые свод правил.

Применим данную возможность к нашей функции, и сделаем так, чтобы аргументы
передавались по ``r-value`` ссылке.

.. code:: c++

    template <class PRED, class T, class... ARGS>
        bool any(PRED&& pred, T&& element, ARGS&&... args)
        {
            if (pred(element))
                return true;
            return any(std::forward<PRED>(pred), std::forward<ARGS>(args)...);
        }

Обратите внимание на применение функции ``std::forward<>()`` к набору
аргументов ``args``. Это не *особый* случай, это применение *паттерна*
к аргументам. Вы реально можете использовать любую другую функцию, и она
применится ко всем аргументам поочередно.


Это еще не всё...
-----------------

Variadic Template годятся не только для создания функций с переменным числом
аргументов (это всего лишь самая простая возможность). Можно, например,
использовать их для наследования.

.. code:: c++

    class A { };
    class B { };

    template <class... CLASSES>
        class Foo : public CLASSES...
        { };

    // ...
    Foo<A, B> foo;

Для того чтобы узнать сколько аргументов хранится в ``parameter pack``, была
введена функция ``sizeof...()``.

.. code:: c++

    template <class... ARGS>
        unsigned int howManyArgs(ARGS... args)
        {
            return sizeof...(args);
        }

    // ...
    std::cout << howManyArgs(1, 2, 3, 4, 5, "foo") << std::endl;


Заключение
----------

**Variadic Template** — большой шаг в развитии языка, который полезен в первую
очередь разработчикам библиотек. На базе Variadic Template функционирую такие
стандартные вещи как классы ``tuple`` и ``function``, функция ``bind()`` 
и т.д. Они проникли в стандартную библиотеку, сделали её лучше и проще.

Но несмотря на это, не стоит забыть о том, что наряду выгодами всегда есть и
недостатки. Недостатком является факт инстанцирования шаблонов — новый
класс/функция будет генерироваться на каждый отдельный случай, что существенно
увеличит размер исполняемого файла.


.. _`«Пользовательских литералах»`: /2012/03/20/user-defined-literals-in-cpp11/
