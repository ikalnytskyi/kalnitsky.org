<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="icon" href="/static/favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/static/apple-touch-icon.png">
    <link rel="manifest" href="/static/manifest.webmanifest">
    <link rel="stylesheet" href="/static/style.css" />
    <link rel="stylesheet" href="/static/pygments.css" />
    <link rel="canonical" href="https://kalnytskyi.com/posts/c-legacy-is-evil/" />
    <link rel="alternate" type="application/atom+xml" href="/feed.xml" title="Ihor Kalnytskyi" />

    <meta name="author" content="Ihor Kalnytskyi" />
    <meta name="description" content="A short story about C legacy in C++, and why it's a bad thing to have." />

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@ikalnytskyi" />
    <meta name="twitter:title" content="C Legacy Is ðŸ˜ˆ Evil" />
    <meta name="twitter:description" content="A short story about C legacy in C++, and why it's a bad thing to have." />

    <meta property="og:title" content="C Legacy Is ðŸ˜ˆ Evil" />
    <meta property="og:description" content="A short story about C legacy in C++, and why it's a bad thing to have." />
    <meta property="og:url" content="https://kalnytskyi.com/posts/c-legacy-is-evil/" />
    <meta property="og:site_name" content="Ihor Kalnytskyi" />
    <meta property="og:type" content="article" />
    <meta property="article:published_time" content="2014-10-25T00:00:00+00:00" />
    <meta property="article:modified_time" content="2022-04-30T23:00:40.838838+00:00" />
    <meta property="article:author" content="Ihor Kalnytskyi" />

    <title>C Legacy Is ðŸ˜ˆ Evil</title>
</head>
<body>
  <div class="banner"><a rel="nofollow" href="https://www.comebackalive.in.ua/donate">Save lives in Ukraine</a> â†’</div>

  <aside>
    <img class="about-pic" src="/about/me.jpg" alt="Ihor's photo" />
    <span class="about-txt"><a href="/about/" rel="me">Ihor Kalnytskyi</a>'s<br />
thoughts & writings</span>

    <div class="nav-wrapper">
    <nav>
      <span><a href="/">Archives</a></span>
      <span><a href="/talks/">Talks</a></span>
      <span><a href="/feed.xml">Feed</a></span>
    </nav>
    </div>
  </aside>

  <main>
    <article>
      <header>
        <time datetime="2014-10-25T00:00:00+00:00">October 25, 2014</time>
        <h1>C Legacy Is ðŸ˜ˆ Evil</h1>
      </header>

      <p>When people ask me Â«What is the first thing I don't like in C++?Â», I
always answer that's a C legacy. I know a lot of C++ bottlenecks, but I
believe that the worst of them is the C legacy.  What do I mean by the
Â«C legacyÂ»? I mean all this stuff that doesn't fit into C++ ideology and
kept in the language for compatibility reason. It was a great advantage
years ago, and it's a worst drawback today.</p>
<p>I have a story as a good example of what I'm talking about. When I was
working at <a href="http://www.gameloft.com/">Gameloft</a>, I was involved in <a href="https://itunes.apple.com/us/app/blitz-brigade-online-multiplayer/id580175049?mt=8">Blitz Brigade</a> project. In the
very late 2013, the HQ decided to revive Android port and I was chosen
to help Android guys to run both server and client sides of the game.</p>
<p>One day an Android guy asked me for help with debugging. His client
application was rejected by the server and he couldn't figure out why
it's happened. Diving in the code, I have found a typical mistake often
occurring in the C world. The interesting thing was that the mistake was
widespread and should have affected both iOS and Android versions.
However, there was 100% reproduce rate for Android version, while for
iOS it haven't been found yet.</p>
<p>Well, let's look at this typical C code that converts a datetime to Unix
timestamp:</p>
<pre><code class="language-cpp"><span class="c1">// year, month, day, hour, min and sec are retrieved from</span>
<span class="c1">// network and have valid values</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">tm</span><span class="w"> </span><span class="n">tm_struct</span><span class="p">;</span><span class="w"></span>

<span class="n">tm_struct</span><span class="p">.</span><span class="n">tm_year</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">year</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1900</span><span class="p">;</span><span class="w"></span>
<span class="n">tm_struct</span><span class="p">.</span><span class="n">tm_mon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">month</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">tm_struct</span><span class="p">.</span><span class="n">tm_mday</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">day</span><span class="p">;</span><span class="w"></span>

<span class="n">tm_struct</span><span class="p">.</span><span class="n">tm_hour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hour</span><span class="p">;</span><span class="w"></span>
<span class="n">tm_struct</span><span class="p">.</span><span class="n">tm_min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">;</span><span class="w"></span>
<span class="n">tm_struct</span><span class="p">.</span><span class="n">tm_sec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sec</span><span class="p">;</span><span class="w"></span>

<span class="n">tm_struct</span><span class="p">.</span><span class="n">tm_wday</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">tm_struct</span><span class="p">.</span><span class="n">tm_yday</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="kt">time_t</span><span class="w"> </span><span class="n">time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">mktime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm_struct</span><span class="p">);</span><span class="w"></span>
</code></pre>
<p>So what's wrong with this code? In first look - nothing is wrong, but for
some reason the resulting <code>time</code> variable was <code>0</code> on Android and a valid
timestamp on iOS. If you come from C world you probable suspect that the
issue is that the <code>tm_struct</code> variable isn't cleared before usage. In C
world we have an unspoken rule:</p>
<blockquote>
<p>Always use <code>memset</code> onto struct variable before usage, because by
default it's filled with garbage.</p>
</blockquote>
<p>Example:</p>
<pre><code class="language-cpp"><span class="k">struct</span><span class="w"> </span><span class="nc">tm</span><span class="w"> </span><span class="n">tm_struct</span><span class="p">;</span><span class="w"></span>
<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm_struct</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">tm_struct</span><span class="p">));</span><span class="w"></span>
</code></pre>
<p>The same rule is also applied in C++ world if we're talking about C
structs, not C++ ones which might be filled properly by means of
constructors. But the <code>tm_struct</code> is a C struct, thus it knows nothing
about constructors and we have to clear it manually.</p>
<p>Actually, the idea is not <em>to clear</em>, but <em>to initialize</em> all members.
It seems like we do initialize all <code>tm</code>'s members, but we are actually
not. Unfortunately, the <code>tm_struct</code> has one more field - <code>tm_isdst</code> -
which is still filled with garbage and leads to mistaken result.</p>
<p>Ok, so why then it works on iOS most of the time and always fails on
Android? I don't know, it just happened and that's all. I think it's
happened because of compiler that may add some clearing code for us
automatically, but I may be wrong.</p>
<p>Why is it so dangerous? Why is there a huge pitfall for C++ in my
opinion?</p>
<p>I believe that C and C++ are different languages with different
ideologies, but with similar syntax. If you wrote your own struct in
C++, you have to define constructor to initialize all members with some
default values. Thus C++ developers don't expect <code>memset</code> right after
struct definition, they're relying on constructors which do that thing
for them.</p>
<p>In real world applications built for different platforms using different
compilers it may be a big challenge to debug because the bug may be
floating, so you spent a lot of time to catch it.</p>
<p>So you should be mindful writing programs in C++, since you can fall
into deep hole of C legacy.</p>

    </article>
  </main>
</body>